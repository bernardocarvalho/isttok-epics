/**
 *
 * Project       : ISTTOK slow Control Sequencer 
 * Docs: https://www-csr.bessy.de/control/SoftDist/sequencer/
 *
 * File          : $Id$
 * Description   : Pulse Sequence State Machine
 *
 * Author(s)     : Bernardo Carvalho (IPFN-IST)
 *               : Paulo Fortuna Carvalho (IPFN-IST)
 * Copyright (c) : (IPFN-IST)
 *
 * Created 5-Mar-2013
 * Revised 01-07-2019
 * Modified 18-Nov-2019
 *
 **/
 
program IsttokSeqExec
/* CONSTANT DECLARATION*/
/*Relays and INPUT (Valleman Board) have negative Logic!*/
short PCF_RELAY_ON = 0;
short PCF_RELAY_OFF= 1;
short PCF_INPUT_ON = 0;
short PCF_INPUT_OFF= 1;
short PCF_PULSE_ON = 1;
 
short STRST_NonStarting = 0;
short STRST_Starting1 = 1;
short STRST_Starting2 = 2;
short STRST_Starting3 = 3;
short STRST_Starting4 = 4;
short STRST_StartingEnd = 5;

short CLNST_NonCleaning = 0;
short CLNST_Cleaning1 = 1;
short CLNST_Cleaning2 = 2;
short CLNST_Cleaning3 = 3;
short CLNST_Cleaning4 = 4;
short CLNST_Cleaning5 = 5;

short WSHTST_NonShoting = 0;
short WSHTST_WaitTrg  = 1;
short WSHTST_Shoting2 = 2;
short WSHTST_Shoting3 = 3;
short WSHTST_Shoting4 = 4;
short WSHTST_Shoting5 = 5;
short WSHTST_Shoting6 = 6;
short WSHTST_Shoting7 = 7;
short WSHTST_Shoting8 = 8;
short WSHTST_Shoting9 = 9;
short WSHTST_Shoting10 = 10;
short WSHTST_Shoting11 = 11;
short WSHTST_Shoting12 = 12;
short WSHTST_ShotEnd = 13;

short  STPST_NonStopping = 0;
short  STPST_Stopping1 = 1;
short  STPST_Stopping2 = 2;
short  STPST_Stopping3 = 3;
//short  STPST_Stopping4 = 4;
//short  STPST_Stopping5 = 5;

short POS_Stopped =0;
short POS_Starting=1;
short POS_Process =2;
short POS_Clean =3;
short POS_WaitShot=4;
short POS_Stopping=5;
short POS_Emergency=6;
 
short ON=1;
short OFF=0;
short START=1;
short STOP=0;
short CLEAN=0;
short SHOT=1;
short NO_ALARM=0;
short MINOR=1;
short MAJOR=2;
short INVALID=3;

/* PV variables  */ 
short IsttokOPSTATE;
assign IsttokOPSTATE to "ISTTOK:central:OPSTATE";
monitor IsttokOPSTATE;
 
short IsttokLastOPSTATE;
assign IsttokLastOPSTATE to "ISTTOK:central:LASTOPSTATE";
monitor IsttokLastOPSTATE;
 
short IsttokOPREQ;
assign IsttokOPREQ to "ISTTOK:central:OPREQ";
monitor IsttokOPREQ;
 
short IsttokProcMode;
assign IsttokProcMode to  "ISTTOK:central:PROCESS-MODE";
monitor IsttokProcMode;
 
short IsttokProcReq;
assign IsttokProcReq  to "ISTTOK:central:PROCESS-REQ";
monitor IsttokProcReq;
 
short STARTINGSTATE;
assign STARTINGSTATE to "ISTTOK:central:STARTINGSTATE";
monitor STARTINGSTATE;

short CLEANINGSTATE;
assign CLEANINGSTATE to "ISTTOK:central:CLEANINGSTATE";
 
short CLEANINGMANMODE;
assign CLEANINGMANMODE to "ISTTOK:central:CLEANINGMANMODE";
monitor CLEANINGMANMODE;

short WSHOTINGSTATE;
assign WSHOTINGSTATE to "ISTTOK:central:WSHOTINGSTATE";
 
short STOPPINGSTATE;
assign STOPPINGSTATE to "ISTTOK:central:STOPPINGSTATE";
monitor STOPPINGSTATE;

short IsttokRPump1_Motor;
assign IsttokRPump1_Motor to "ISTTOK:central:RPump1-Motor";
 
short IsttokRPump1_Valve;
assign IsttokRPump1_Valve to "ISTTOK:central:RPump1-Valve";
 
short IsttokRPump2_Motor;
assign IsttokRPump2_Motor to "ISTTOK:central:RPump2-Motor";
 
short IsttokRPump2_Valve;
assign IsttokRPump2_Valve to "ISTTOK:central:RPump2-Valve";
 
short IsttokTMPump1_ControllerOff;
assign IsttokTMPump1_ControllerOff to "ISTTOK:central:TMPump1-ControllerOff";
 
short IsttokTMPump1_ControllerOn;
assign IsttokTMPump1_ControllerOn to "ISTTOK:central:TMPump1-ControllerOn";
 
short IsttokTMPump1_MotorOff;
assign IsttokTMPump1_MotorOff to "ISTTOK:central:TMPump1-MotorOff";
 
short IsttokTMPump1_MotorOn;
assign IsttokTMPump1_MotorOn to "ISTTOK:central:TMPump1-MotorOn";
 
short IsttokTMPump2_Motor;
assign IsttokTMPump2_Motor to "ISTTOK:central:TMPump2-Motor";
 
short IsttokTMPump1_NormalOperation;
assign IsttokTMPump1_NormalOperation to "ISTTOK:central:TMPump1-NormalOperation";
monitor IsttokTMPump1_NormalOperation;
 
short IsttokTMPump1_Power;
assign IsttokTMPump1_Power to "ISTTOK:central:TMPump1-Power";
monitor IsttokTMPump1_Power;
 
short IsttokTMPump1_Emergency;
assign IsttokTMPump1_Emergency to "ISTTOK:central:TMPump1-Emergency";
monitor IsttokTMPump1_Emergency;
 
short IsttokTMPump1_ManualValve;
assign IsttokTMPump1_ManualValve to "ISTTOK:central:TMPump1-ManualValve";
monitor IsttokTMPump1_ManualValve;
 
short IsttokTMPump2_Emergency;
assign IsttokTMPump2_Emergency to "ISTTOK:central:TMPump2-Emergency";
monitor IsttokTMPump2_Emergency;
 
float IsttokRPump1_Pressure;
assign IsttokRPump1_Pressure to "ISTTOK:central:RPump1-Pressure";
monitor IsttokRPump1_Pressure;
 
float IsttokRPump2_Pressure;
assign IsttokRPump2_Pressure to "ISTTOK:central:RPump2-Pressure";
monitor IsttokRPump2_Pressure;

short IsttokShotBuzzer;
assign IsttokShotBuzzer to "ISTTOK:central:Buzzer";
 
short IsttokShotLab_WarningLight;
assign IsttokShotLab_WarningLight to "ISTTOK:central:Lab-WarningLight";
 
short IsttokShotGasIS_Valves;
assign IsttokShotGasIS_Valves to "ISTTOK:central:GasIS-Valves";
 
short IsttokShotVVessel_Filament;
assign IsttokShotVVessel_Filament to "ISTTOK:central:VVessel-Filament";
 
short IsttokShotCapBank_Charge;
assign IsttokShotCapBank_Charge to "ISTTOK:central:CapBank-Charge";
 
short IsttokShotCapBank_Discharge;
assign IsttokShotCapBank_Discharge to "ISTTOK:central:CapBank-Discharge";
 
short IsttokShotClean_TorContactor;
assign IsttokShotClean_TorContactor to "ISTTOK:central:Clean-TorContactor";
 
short IsttokShotClean_TorPneuBreaker;
assign IsttokShotClean_TorPneuBreaker to "ISTTOK:central:Clean-TorPneuBreaker";
 
short IsttokShotShot_TorPSTrigger;
assign IsttokShotShot_TorPSTrigger to "ISTTOK:central:Shot-TorPSTrigger";
monitor IsttokShotShot_TorPSTrigger;
 
short IsttokShotShot_TorPSDisable;
assign IsttokShotShot_TorPSDisable to "ISTTOK:central:Shot-TorPSDisable";
 
short IsttokShotClean_PrimContactor;
assign IsttokShotClean_PrimContactor to "ISTTOK:central:Clean-PrimContactor";
 
short IsttokShotClean_PrimPneuBreaker;
assign IsttokShotClean_PrimPneuBreaker to "ISTTOK:central:Clean-PrimPneuBreaker";
 
short IsttokShotCountdown;
assign IsttokShotCountdown to "ISTTOK:central:COUNTDOWN";
monitor IsttokShotCountdown; 
 
string IsttokShotCountdownScan;
assign IsttokShotCountdownScan to "ISTTOK:central:COUNTDOWN.SCAN";
 
short IsttokEmergency;
assign IsttokEmergency to "ISTTOK:central:Emergency";
monitor IsttokEmergency;
 
short IsttokTTSystem_tzero;
assign IsttokTTSystem_tzero to  "ISTTOK:central:TTSystem-tzero";
monitor IsttokTTSystem_tzero;
 
//string tmp1_stat;
 
/* Trace message record limited to 40 characters */
string msg;
assign msg to "ISTTOK:central:TraceMessage.VAL";
monitor msg;

/* Main Pulse State Set */
ss PulseSequence {
    state init {
          entry {
            strcpy(msg, "INIT: Sequence Entry");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            
            strcpy(msg, "Initializing...");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            
            IsttokShotCountdown = 160;
            pvPut(IsttokShotCountdown);
            
//            IsttokProcMode = OFF; // UPON POWER-DOWN OR FAILURE PREVENT TO ENTER WAITSHOT ON POWER-UP!
//            pvPut(IsttokProcMode);
            
            IsttokShotClean_PrimContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_PrimContactor);
 
            IsttokShotClean_PrimPneuBreaker = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_PrimPneuBreaker);
 
            IsttokShotBuzzer = PCF_RELAY_OFF;
            pvPut(IsttokShotBuzzer);
 
            IsttokShotCapBank_Charge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Charge);
 
            IsttokShotCapBank_Discharge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Discharge);
 
            IsttokShotVVessel_Filament = PCF_RELAY_OFF;
            pvPut(IsttokShotVVessel_Filament);
 
            IsttokShotGasIS_Valves = PCF_RELAY_OFF;
            pvPut(IsttokShotGasIS_Valves);
            
            IsttokShotLab_WarningLight = PCF_RELAY_OFF;
            pvPut(IsttokShotLab_WarningLight);
 
            IsttokShotClean_TorPneuBreaker = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorPneuBreaker);
 
            IsttokShotClean_TorContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorContactor);
            
            IsttokShotShot_TorPSDisable = PCF_RELAY_OFF;
            pvPut(IsttokShotShot_TorPSDisable);
 
            IsttokTMPump2_Motor = PCF_RELAY_OFF;
            pvPut(IsttokTMPump2_Motor);
 
            IsttokShotShot_TorPSTrigger= OFF;
            pvPut(IsttokShotShot_TorPSTrigger);
            
            IsttokTMPump1_ControllerOff = OFF;
            pvPut(IsttokTMPump1_ControllerOff);
 
            IsttokTMPump1_ControllerOn = OFF;
            pvPut(IsttokTMPump1_ControllerOn);
 
            IsttokTMPump1_MotorOff = OFF;
            pvPut(IsttokTMPump1_MotorOff);
 
            IsttokTMPump1_MotorOn = OFF;
            pvPut(IsttokTMPump1_MotorOn);
 
            /* CHECK PRIMARY PRESSURES AND PREVENT STARTING IF REQUIRED TODO: Unfold ifs
            if( (pvStatus(IsttokRPump1_Pressure) != pvStatOK) && (pvStatus(IsttokRPump1_Pressure) != pvStatOK)) {
                IsttokOPREQ = STOP;
                pvPut(IsttokOPREQ);
            }
            */
            if ((IsttokTMPump1_Power == PCF_INPUT_OFF)) {
                strcpy(msg, "TMP1 Controller is OFF");
                pvPut(msg);
                errlogSevPrintf(NO_ALARM, "%s\n",msg);
            }else{
                strcpy(msg, "TMP1 Controller is ON");
                pvPut(msg);
                errlogSevPrintf(NO_ALARM, "%s\n",msg);
            }
        }
        when (delay(5) && IsttokOPREQ == STOP)  {
            strcpy(msg, "State to Stopping");
            pvPut(msg);
            errlogSevPrintf(MINOR, "%s\n",msg);
            /* State change to Stopping */
            IsttokOPSTATE = POS_Stopping;
            pvPut(IsttokOPSTATE);
        } state Stopping 		
        when (delay(5) && IsttokOPREQ == START ) {
            strcpy(msg, "State to Starting");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
	    /*
            IsttokRPump1_Motor = PCF_RELAY_OFF;
            pvPut(IsttokRPump1_Motor);
            IsttokRPump2_Motor = PCF_RELAY_OFF;
            pvPut(IsttokRPump2_Motor);
            IsttokRPump1_Valve = PCF_RELAY_OFF;
            pvPut(IsttokRPump1_Valve);
            IsttokRPump2_Valve = PCF_RELAY_OFF;
            pvPut(IsttokRPump2_Valve);
           */
	   /* State change to Starting */
            IsttokOPSTATE = POS_Starting;
            pvPut(IsttokOPSTATE);
        } state Starting
    }
    /* State Stopped */
    state Stopped {
	entry{
            IsttokLastOPSTATE = POS_Stopped;
            pvPut(IsttokLastOPSTATE);
	}
        when ((IsttokOPREQ == START) && (IsttokEmergency == OFF)) {
            strcpy(msg, "State to Starting");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Starting */
            IsttokOPSTATE = POS_Starting;
            pvPut(IsttokOPSTATE);
        } state Starting
        when((IsttokEmergency == ON)){
            strcpy(msg, "Emergency from Stopped");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Emergency*/
            IsttokOPSTATE = POS_Stopped;
            pvPut(IsttokOPSTATE);
        } state Emergency
    }
    /* State Starting */
    state Starting {
	entry{
            IsttokOPSTATE = POS_Starting;
            pvPut(IsttokOPSTATE);
	}
        when(IsttokEmergency == ON) {
            strcpy(msg, "Emergency from Starting");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Emergency*/
        //    IsttokOPSTATE = POS_Starting;
        //    pvPut(IsttokOPSTATE);
        } state Emergency
        when (IsttokOPREQ == STOP) {
            strcpy(msg, "State to Stopping");
            pvPut(msg);
            errlogSevPrintf(MINOR, "%s\n",msg);
            /* Pulse state change to Stopping */
            IsttokOPSTATE = POS_Stopping;
            pvPut(IsttokOPSTATE);
        } state Stopping
        when (STARTINGSTATE == STRST_StartingEnd ) {
            strcpy(msg, "State to Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Process*/
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state Process
    }
    /* State Process */
    state Process {
	entry{
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
            IsttokLastOPSTATE = POS_Process;
            pvPut(IsttokLastOPSTATE);
            IsttokShotShot_TorPSDisable = PCF_RELAY_OFF;
            pvPut(IsttokShotShot_TorPSDisable);
	}
        when(IsttokEmergency == ON){
            strcpy(msg, "Emergency from Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Emergency*/
        } state Emergency

        when ( pvStatus(IsttokRPump1_Pressure) != pvStatOK || pvStatus(IsttokRPump2_Pressure) != pvStatOK || pvStatus(IsttokTMPump2_Emergency) != pvStatOK) {
            /* Vacuum emergency: Pulse state change to Stopping */
            IsttokOPSTATE = POS_Stopping;
            pvPut(IsttokOPSTATE);
        } state Stopping

        when (IsttokOPREQ==STOP || IsttokTMPump1_ManualValve == OFF) {
            /*Just to be sure */
            IsttokProcReq = STOP;
            pvPut(IsttokProcReq);

            strcpy(msg, "State to Stopping");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
    //        pvPut(msg);
   //         errlogSevPrintf(NO_ALARM, "%s\n",msg);
  //          strcpy(msg, "Toroidal Shot Disable");
   //         pvPut(msg);
    //        errlogSevPrintf(NO_ALARM, "%s\n",msg);
            //IsttokShotShot_TorPSDisable = PCF_RELAY_OFF;
            //pvPut(IsttokShotShot_TorPSDisable);
            /* Pulse state change to Stopping */
            IsttokOPSTATE = POS_Stopping;
            pvPut(IsttokOPSTATE);
        } state Stopping
        when (IsttokProcReq==START && IsttokProcMode==CLEAN ) {
            strcpy(msg, "State to Clean");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
 //           strcpy(msg, "Toroidal Shot Disable");
 //           pvPut(msg);
 //           errlogSevPrintf(NO_ALARM, "%s\n",msg);
            //IsttokShotShot_TorPSDisable = PCF_RELAY_OFF;
            //pvPut(IsttokShotShot_TorPSDisable);
            /* Pulse state change to Clean */
            IsttokOPSTATE = POS_Clean;
            pvPut(IsttokOPSTATE);
        } state Clean
        when (IsttokProcReq==START && IsttokProcMode==SHOT ) {
            strcpy(msg, "State to WaitShot");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            strcpy(msg, "Toroidal Shot Enable");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotShot_TorPSDisable = PCF_RELAY_ON;
            pvPut(IsttokShotShot_TorPSDisable);
            /* Pulse state change to WaitShot */
            IsttokOPSTATE = POS_WaitShot;
            pvPut(IsttokOPSTATE);
        } state WaitShot
    }
    /* State Clean */
    state Clean {
        when ( IsttokOPREQ == STOP || IsttokProcReq==STOP)  {
            strcpy(msg, "State to Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /*Just to be sure */
            IsttokProcReq = STOP;
            pvPut(IsttokProcReq);
            /* Pulse state change to Process */
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state Process
        when(IsttokEmergency == ON){
            strcpy(msg, "Emergency from Clean");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Emergency*/
            IsttokOPSTATE = POS_Clean;
            pvPut(IsttokOPSTATE);
        } state Emergency
 
    }
    /* State WaitShot */
    state WaitShot {
        when ( (IsttokOPREQ==STOP) || (IsttokProcReq==STOP) ) {
            strcpy(msg, "State to Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /*Just to be sure*/
            IsttokProcReq = STOP;
            pvPut(IsttokProcReq);
            /* Pulse state change to Process */
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state Process
        when((IsttokEmergency == ON)){
            strcpy(msg, "Emergency from WaitShot");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Emergency*/
            IsttokOPSTATE = POS_WaitShot;
            pvPut(IsttokOPSTATE);
        } state Emergency
    }
    /* State Stopping */
    state Stopping {
	entry{	
            IsttokLastOPSTATE = POS_Stopping;
            pvPut(IsttokLastOPSTATE);
	}
        when (STOPPINGSTATE == STPST_Stopping3) {
            IsttokOPSTATE = POS_Stopped;
            pvPut(IsttokOPSTATE);
        } state Stopped
    }

    /*State Emergency*/
    state Emergency {
	entry {
            strcpy(msg, "Toroidal Shot Disable");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotShot_TorPSDisable = PCF_RELAY_OFF;
            pvPut(IsttokShotShot_TorPSDisable);
            
            strcpy(msg, "EMERGENCY: CAPBANK Charge OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotCapBank_Charge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Charge);
            
            strcpy(msg, "EMERGENCY: CAPBANK CrowBar Close");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotCapBank_Discharge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Discharge);
            
            strcpy(msg, "EMERGENCY: GIS Valves CLOSE");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotGasIS_Valves = PCF_RELAY_OFF;
            pvPut(IsttokShotGasIS_Valves);
            
            strcpy(msg, "EMERGENCY: Filament OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotVVessel_Filament = PCF_RELAY_OFF;
            pvPut(IsttokShotVVessel_Filament);
	}
        when (delay(1.0) && (IsttokEmergency == OFF) && (IsttokOPSTATE == POS_WaitShot || IsttokOPSTATE==POS_Clean) ){
            /* Pulse state change to Process */
            strcpy(msg, "State to Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokProcReq = STOP;
            pvPut(IsttokProcReq);
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state Process
        when (delay(1.0) && (IsttokEmergency == OFF) && (IsttokOPSTATE == POS_Process)){
            /* Pulse state change to Process */
            strcpy(msg, "State to Process");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state Process
        when (delay(1.0) && (IsttokEmergency == OFF) && (IsttokOPSTATE == POS_Starting)){
            
            strcpy(msg, "State to Stopped");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokOPREQ = STOP;
            pvPut(IsttokOPREQ);
            /* Pulse state change to Stopped */
            IsttokOPSTATE = POS_Stopped;
            pvPut(IsttokOPSTATE);
        } state Stopped

        when (delay(1.0) && (IsttokEmergency == OFF) && (IsttokOPSTATE == POS_Stopped)){
            
            strcpy(msg, "State to Stopped");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            /* Pulse state change to Stopped */
            IsttokOPSTATE = POS_Stopped;
            pvPut(IsttokOPSTATE);
        } state Stopped
    }
}

/* Starting State Set */
ss StartingSequence {
    state NonStarting {
        entry {
            STARTINGSTATE = STRST_NonStarting;
            pvPut(STARTINGSTATE);
        }
        when (IsttokOPSTATE == POS_Starting) {
            strcpy(msg, "Rotary Pump1 ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump1_Motor = PCF_RELAY_OFF;
            pvPut(IsttokRPump1_Motor);
            strcpy(msg, "Rotary Pump2 ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump2_Motor = PCF_RELAY_OFF;
            pvPut(IsttokRPump2_Motor);
            STARTINGSTATE = STRST_Starting1;
            pvPut(STARTINGSTATE);
        } state Starting1
    }
    state Starting1 {
        when (IsttokOPSTATE != POS_Starting ) {
            strcpy(msg, "Starting1 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
          //  IsttokSTARTINGSTATE = STRST_NonStarting;
          //  pvPut(IsttokSTARTINGSTATE);
        } state NonStarting
        when (delay(5.0)) {
            strcpy(msg, "Rotary Valve1 OPEN");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump1_Valve = PCF_RELAY_OFF;
            pvPut(IsttokRPump1_Valve);
            strcpy(msg, "Rotary Valve2 OPEN");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump2_Valve = PCF_RELAY_OFF;
            pvPut(IsttokRPump2_Valve);
            STARTINGSTATE = STRST_Starting2;
            pvPut(STARTINGSTATE);
        } state Starting2
    }
    state Starting2 {
        when (IsttokOPSTATE != POS_Starting ) {
            strcpy(msg, "Starting2 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            STARTINGSTATE = STRST_NonStarting;
            pvPut(STARTINGSTATE);
        } state NonStarting
        when (IsttokTMPump1_ManualValve == ON) {
            strcpy(msg, "Manual Valve Open Checked");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            STARTINGSTATE = STRST_Starting3;
            pvPut(STARTINGSTATE);
        } state Starting3
    }
    state Starting3 {
        when (IsttokOPSTATE != POS_Starting) {
            strcpy(msg, "Starting3 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            STARTINGSTATE = STRST_NonStarting;
            pvPut(STARTINGSTATE);
        } state NonStarting
        when ( (pvStatus(IsttokRPump1_Pressure) == pvStatOK) && (pvStatus(IsttokRPump1_Pressure) == pvStatOK)) {
/*  TODO unfold when      when (((IsttokRPump1_Pressure < IsttokRPump1_PressureLowLimit) && (IsttokRPump2_Pressure < IsttokRPump2_PressureLowLimit)) ) { */
 
                strcpy(msg, "TMP1 MotorOn ON" );
                pvPut(msg);
                errlogSevPrintf(NO_ALARM, "%s\n",msg);
                IsttokTMPump1_MotorOn = ON;
                pvPut(IsttokTMPump1_MotorOn);
                strcpy(msg, "TMP2 Motor ON" );
                pvPut(msg);
                errlogSevPrintf(NO_ALARM, "%s\n",msg);
                IsttokTMPump2_Motor = PCF_RELAY_ON;
                pvPut(IsttokTMPump2_Motor);
/* 
            if(IsttokTMPump1_NormalOperation == PCF_INPUT_ON){
	            sprintf(tmp1_stat, "ON");
            }else{
        	    sprintf(tmp1_stat, "OFF");
            }
 
            sprintf(msg, "TMPNO = [1:%s]", tmp1_stat);
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
*/
	    STARTINGSTATE = STRST_Starting4;
            pvPut(STARTINGSTATE);
        } state Starting4
    }
    state Starting4 {
        when (IsttokOPSTATE != POS_Starting ) {
            strcpy(msg, "Starting4 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            //IsttokSTARTINGSTATE = STRST_NonStarting;
            //pvPut(IsttokSTARTINGSTATE);
        } state NonStarting
        when (IsttokTMPump1_NormalOperation == PCF_INPUT_ON) {    
            strcpy(msg, "TMP1 operating Normal");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            STARTINGSTATE = STRST_StartingEnd;
            pvPut(STARTINGSTATE);
        } state StartingEnd
    }
    state StartingEnd {
        when (IsttokOPSTATE != POS_Starting ) {
            //strcpy(msg, "State to Process");
           // pvPut(msg);
            //errlogSevPrintf(NO_ALARM, "%s\n",msg);
            //IsttokSTARTINGSTATE = STRST_NonStarting;
            //pvPut(IsttokSTARTINGSTATE);
        } state NonStarting
    }
}

ss CleaningSequence{
    state NonCleaning{
        entry{
            strcpy(msg, "GIS Valves CLOSE");
            pvPut(msg);    
            IsttokShotGasIS_Valves = PCF_RELAY_OFF;
            pvPut(IsttokShotGasIS_Valves);
                
            strcpy(msg, "Filament OFF");
            pvPut(msg);    
            IsttokShotVVessel_Filament = PCF_RELAY_OFF;
            pvPut(IsttokShotVVessel_Filament);
                
            strcpy(msg, "Primary_CT OFF");
            pvPut(msg);
            IsttokShotClean_PrimContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_PrimContactor);

            strcpy(msg, "Toroidal_BK OPEN");
            pvPut(msg);
            IsttokShotClean_TorPneuBreaker = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorPneuBreaker);

            strcpy(msg, "Toroidal_CT OFF");
            pvPut(msg);
            IsttokShotClean_TorContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorContactor);

            CLEANINGSTATE = CLNST_NonCleaning;
            pvPut(CLEANINGSTATE);

            errlogSevPrintf(NO_ALARM, "%s\n",msg);

        }
        when(delay(1.0) && CLEANINGMANMODE == 1 && IsttokOPSTATE == POS_Clean){
            strcpy(msg, "Initiating Auto Cleaning...");
            pvPut(msg);
            strcpy(msg, "GIS Valves OPEN");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotGasIS_Valves = PCF_RELAY_ON;
            pvPut(IsttokShotGasIS_Valves);
	    CLEANINGSTATE = CLNST_Cleaning1;
	    pvPut(CLEANINGSTATE);
        } state Cleaning1
    }
    state Cleaning1 {
        when (delay(1.0) && (IsttokOPSTATE != POS_Clean )) {
            // Reversing Cleaning
            strcpy(msg, "GIS Valves CLOSE");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotGasIS_Valves = PCF_RELAY_OFF;
            pvPut(IsttokShotGasIS_Valves);
        } state NonCleaning
        when (delay(2.0) && CLEANINGMANMODE == 1 && IsttokOPSTATE == POS_Clean ) {
            strcpy(msg, "Filament ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotVVessel_Filament = PCF_RELAY_ON;
            pvPut(IsttokShotVVessel_Filament);
	    CLEANINGSTATE = CLNST_Cleaning2;
	    pvPut(CLEANINGSTATE);
        } state Cleaning2
    }
    state Cleaning2{
        when (delay(1.0) && IsttokOPSTATE != POS_Clean ) {
            // Reversing Cleaning
            strcpy(msg, "Filament OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotVVessel_Filament = PCF_RELAY_OFF;
            pvPut(IsttokShotVVessel_Filament);
	    CLEANINGSTATE = CLNST_Cleaning1;
	    pvPut(CLEANINGSTATE);
        } state Cleaning1
        when (delay(2.0) && CLEANINGMANMODE == 1 && IsttokOPSTATE == POS_Clean) {
            strcpy(msg, "Primary-CT ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_PrimContactor = PCF_RELAY_ON;
            pvPut(IsttokShotClean_PrimContactor);
	    CLEANINGSTATE = CLNST_Cleaning3;
	    pvPut(CLEANINGSTATE);
        } state Cleaning3
    }
    state Cleaning3{
        when(delay(1.0) && IsttokOPSTATE != POS_Clean){
            strcpy(msg, "Primary-CT OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_PrimContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_PrimContactor);
	    CLEANINGSTATE = CLNST_Cleaning2;
	    pvPut(CLEANINGSTATE);
        } state Cleaning2
        when(delay(2.0) && CLEANINGMANMODE == 1 && IsttokOPSTATE == POS_Clean){
            strcpy(msg, "Toroidal-BK CLOSE");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_TorPneuBreaker = PCF_RELAY_ON;
            pvPut(IsttokShotClean_TorPneuBreaker);
	    CLEANINGSTATE = CLNST_Cleaning4;
	    pvPut(CLEANINGSTATE);
        } state Cleaning4

    }
    state Cleaning4{
        when(delay (1.0) && IsttokOPSTATE != POS_Clean){
            strcpy(msg, "Toroidal-BK OPEN");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_TorPneuBreaker = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorPneuBreaker);
	    CLEANINGSTATE = CLNST_Cleaning3;
	    pvPut(CLEANINGSTATE);
        } state Cleaning3
        when (delay(2.0) && CLEANINGMANMODE == 1 && IsttokOPSTATE == POS_Clean){
            strcpy(msg, "Toroidal-CT ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_TorContactor = PCF_RELAY_ON;
            pvPut(IsttokShotClean_TorContactor);
	    CLEANINGSTATE = CLNST_Cleaning5;
	    pvPut(CLEANINGSTATE);
        } state Cleaning5

    }
    state Cleaning5{
        when(delay(1.0) && IsttokOPSTATE != POS_Clean){
            strcpy(msg, "Toroidal-CT OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotClean_TorContactor = PCF_RELAY_OFF;
            pvPut(IsttokShotClean_TorContactor);
	    CLEANINGSTATE = CLNST_Cleaning4;
	    pvPut(CLEANINGSTATE);
        } state Cleaning4
    }
}

ss ShotSequence {
    state NonShoting {
        entry {
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
            strcpy(IsttokShotCountdownScan, "Passive");
            pvPut(IsttokShotCountdownScan);
        }
        when( IsttokOPSTATE == POS_WaitShot ){
            strcpy(msg, "Waiting for Trigger...");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotCountdown = 0;
            pvPut(IsttokShotCountdown);
            strcpy(IsttokShotCountdownScan, "1 second");
            pvPut(IsttokShotCountdownScan);
            WSHOTINGSTATE = WSHTST_WaitTrg;
            pvPut(WSHOTINGSTATE);
        } state ShotWaitTrg 
    }
    state ShotWaitTrg {
        when ((IsttokShotCountdown > 1800) || (IsttokOPSTATE != POS_WaitShot)) { 		//     
            strcpy(msg, "Shoting Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            strcpy(IsttokShotCountdownScan, "Passive");
            pvPut(IsttokShotCountdownScan);
            IsttokProcReq = STOP;
            pvPut(IsttokProcReq);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
            IsttokOPSTATE = POS_Process;
            pvPut(IsttokOPSTATE);
        } state NonShoting
        when( IsttokTTSystem_tzero == 0 ){
            strcpy(msg, "Trigger received...");
            pvPut(msg);
            IsttokShotCountdown = -70;
            pvPut(IsttokShotCountdown);
            WSHOTINGSTATE = WSHTST_Shoting2;
            pvPut(WSHOTINGSTATE);
        } state Shoting2
    }
    state Shoting2 {
        when (IsttokOPSTATE != POS_WaitShot) {
            strcpy(msg, "Shoting 2 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
        } state ShotWaitTrg 
        when ((IsttokOPSTATE == POS_WaitShot) && (IsttokShotCountdown == -61)) {
            strcpy(msg, "Buzzer 1-Sound");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotBuzzer = 1;
            pvPut(IsttokShotBuzzer);
            strcpy(msg, "CAPBANK Crowbar Open");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotCapBank_Discharge = PCF_RELAY_ON;
            pvPut(IsttokShotCapBank_Discharge);
            strcpy(msg, "Lights ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotLab_WarningLight = PCF_RELAY_ON;
            pvPut(IsttokShotLab_WarningLight);
            WSHOTINGSTATE = WSHTST_Shoting3;
            pvPut(WSHOTINGSTATE);
        } state Shoting3
    }
    state Shoting3 {
        when (IsttokOPSTATE != POS_WaitShot) {
            strcpy(msg, "Shoting3 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
        } state ShotWaitTrg 
        when (IsttokShotCountdown == -60) {
            strcpy(msg, "GIS Valves OPEN");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotGasIS_Valves = PCF_RELAY_ON;
            pvPut(IsttokShotGasIS_Valves);
            WSHOTINGSTATE = WSHTST_Shoting4;
            pvPut(WSHOTINGSTATE);
        } state Shoting4
    }
    state Shoting4 {
        when ((IsttokOPSTATE != POS_WaitShot) && (IsttokShotCountdown == 160)) {
            strcpy(msg, "Shoting4 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
        } state NonShoting
        when (IsttokShotCountdown == -59) {
            WSHOTINGSTATE = WSHTST_Shoting5;
            pvPut(WSHOTINGSTATE);
        } state Shoting5
    }
    state Shoting5 {
        when ((IsttokOPSTATE != POS_WaitShot) && (IsttokShotCountdown == 160)) {
            strcpy(msg, "Shoting5 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
        } state NonShoting
        when (IsttokShotCountdown == -46) {
            strcpy(msg, "CAPBANK Charge ON" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotCapBank_Charge = PCF_RELAY_ON;
            pvPut(IsttokShotCapBank_Charge);
            WSHOTINGSTATE = WSHTST_Shoting6;
            pvPut(WSHOTINGSTATE);
        } state Shoting6
    }
    state Shoting6 {
        when (IsttokShotCountdown == -16) {
            strcpy(msg, "CAPBANK Charge OFF" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotCapBank_Charge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Charge);
            WSHOTINGSTATE = WSHTST_Shoting7;
            pvPut(WSHOTINGSTATE);
        } state Shoting7
    }
    state Shoting7 {
        when (IsttokShotCountdown == -11) {
            strcpy(msg, "Buzzer 2-Sound" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotBuzzer = 1;
            pvPut(IsttokShotBuzzer);
            strcpy(msg, "Filament ON");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokShotVVessel_Filament = PCF_RELAY_ON;
            pvPut(IsttokShotVVessel_Filament);
            WSHOTINGSTATE = WSHTST_Shoting8;
            pvPut(WSHOTINGSTATE);
       } state Shoting8
    }
    state Shoting8 {
/*
         when ((IsttokOPSTATE != POS_WaitShot) && (IsttokShotCountdown == 160)) {
            strcpy(msg, "Shoting8 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
        } state NonShoting
*/
        when (IsttokShotCountdown == -4) {
            strcpy(msg, "Toroidal PS Trigger");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
//          PS Trigger Pulse
            IsttokShotShot_TorPSTrigger = ON;
            pvPut(IsttokShotShot_TorPSTrigger);        
            WSHOTINGSTATE = WSHTST_Shoting9;
            pvPut(WSHOTINGSTATE);
       } state Shoting9
    }
    state Shoting9 {
        when (IsttokShotCountdown == -2) {
            strcpy(msg, "Ready for SHOT" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            WSHOTINGSTATE = WSHTST_Shoting10;
            pvPut(WSHOTINGSTATE);
       } state Shoting10
    }
    state Shoting10 {
        when (IsttokShotCountdown == 0) {
            strcpy(msg, "CAPBANK CrowBar Close" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotCapBank_Discharge = PCF_RELAY_OFF;
            pvPut(IsttokShotCapBank_Discharge);
            WSHOTINGSTATE = WSHTST_Shoting11;
            pvPut(WSHOTINGSTATE);
       } state Shoting11
    }
    state Shoting11 {
        when (IsttokShotCountdown == 1) {
            strcpy(msg, "GIS Valves CLOSE" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotGasIS_Valves = 1;
            pvPut(IsttokShotGasIS_Valves);
            strcpy(msg, "Filament OFF" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotVVessel_Filament = 1;
            pvPut(IsttokShotVVessel_Filament);
            WSHOTINGSTATE = WSHTST_Shoting12;
            pvPut(WSHOTINGSTATE);
        } state Shoting12
    }
    state Shoting12 {
        when (IsttokShotCountdown == 2) {
            strcpy(msg, "Lights OFF and Recovering..." );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            IsttokShotLab_WarningLight = PCF_RELAY_OFF;
            pvPut(IsttokShotLab_WarningLight);
            WSHOTINGSTATE = WSHTST_ShotEnd;
            pvPut(WSHOTINGSTATE);
        } state ShotEnd
    }
    state ShotEnd {
/*
        when ((IsttokOPSTATE != POS_WaitShot ) && (IsttokShotCountdown == 160) ) {
            strcpy(msg, "Shoting13 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
        } state NonShoting
*/
        when (IsttokShotCountdown > 160) {
            strcpy(msg, "Terminated");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
//            IsttokShotCountdown = 0;
//            pvPut(IsttokShotCountdown);
            WSHOTINGSTATE = WSHTST_WaitTrg;
            pvPut(WSHOTINGSTATE);
        } state ShotWaitTrg 
    }
}

/* Stopping State Set */
ss StoppingSequence {
    state NonStopping {
 	entry {
            STOPPINGSTATE = STPST_NonStopping; 
            pvPut(STOPPINGSTATE);
        }
        when (IsttokOPSTATE == POS_Stopping) {
            strcpy(msg, "Stopping Mode: Stopping1");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);

	    IsttokTMPump1_MotorOff = ON;
            pvPut(IsttokTMPump1_MotorOff);

 	    IsttokTMPump2_Motor = PCF_RELAY_OFF;
            pvPut(IsttokTMPump2_Motor);
            STOPPINGSTATE = STPST_Stopping1;
            pvPut(STOPPINGSTATE);
        } state Stopping1 
    }
   state Stopping1 {
      when (IsttokOPSTATE != POS_Stopping ) {
/*
            strcpy(msg, "Stopping Mode: NonStopping");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);

            STOPPINGSTATE = STPST_NonStopping; 
            pvPut(STOPPINGSTATE);
*/
      } state NonStopping 

      when (delay(5.0) && IsttokTMPump1_ManualValve==OFF) {
            strcpy(msg, "Manual Valve Closed Checked");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump1_Motor = PCF_RELAY_ON;
            pvPut(IsttokRPump1_Motor);
            strcpy(msg, "Rotary Pumps 1 & 2 OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump2_Motor = PCF_RELAY_ON;
            pvPut(IsttokRPump2_Motor);
            STOPPINGSTATE = STPST_Stopping2;
            pvPut(STOPPINGSTATE);
        } state Stopping2 
    }
   state Stopping2 {
        when (IsttokOPSTATE != POS_Stopping ) {
         //   STOPPINGSTATE = STPST_NonStopping; 
         //   pvPut(STOPPINGSTATE);
        } state NonStopping 
    	when (delay(5)) {
            IsttokRPump1_Valve = PCF_RELAY_ON;
            pvPut(IsttokRPump1_Valve);
            strcpy(msg, "Rotary Valves 1 & 2 CLOSE");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump2_Valve = PCF_RELAY_ON;
            pvPut(IsttokRPump2_Valve);
            STOPPINGSTATE = STPST_Stopping3;
            pvPut(STOPPINGSTATE);
	} state Stopping3 
   }	
   state Stopping3 {
        when (IsttokOPSTATE != POS_Stopping ) {
        //    STOPPINGSTATE = STPST_NonStopping; 
        //    pvPut(STOPPINGSTATE);
        } state NonStopping 
   }
}

/**** END PROGRAM ***/
	
/*        when (IsttokShotCountdown > 159) {
            strcpy(msg, "Toroidal Field Recovered" );
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            WSHOTINGSTATE = WSHTST_Shoting12;
            pvPut(WSHOTINGSTATE);
        } state Shoting12
    state Shoting12 {
        when ((IsttokOPSTATE != POS_WaitShot ) && (IsttokShotCountdown == 160) ) {
            strcpy(msg, "Shoting12 Out");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
            WSHOTINGSTATE = WSHTST_NonShoting;
            pvPut(WSHOTINGSTATE);
        } state NonShoting
        when (IsttokShotCountdown >= 160) {
            strcpy(msg, "Terminated");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n", msg);
//            strcpy(IsttokShotCountdownScan, "Passive");
//            pvPut(IsttokShotCountdownScan);
//            IsttokShotCountdown = 0;
//            pvPut(IsttokShotCountdown);
        } state ShotWaitTrg 
    }



	entry{	
            IsttokRPump1_Motor = PCF_RELAY_ON;
            pvPut(IsttokRPump1_Motor);
            strcpy(msg, "Rotary Pumps 1/2 OFF");
            pvPut(msg);
            errlogSevPrintf(NO_ALARM, "%s\n",msg);
            IsttokRPump2_Motor = PCF_RELAY_ON;
            pvPut(IsttokRPump2_Motor);
            //IsttokLastOPSTATE = POS_Process;
            //pvPut(IsttokLastOPSTATE);
	}
//        } state Stopping

*/

